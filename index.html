<!doctype html>
<html class="no-js" lang="">
    <head>
      <meta charset="utf-8">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      <title></title>
      <meta name="description" content="">
      <meta name="viewport" content="width=device-width, initial-scale=1">

      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
      <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.1.15/leaflet-providers.min.js"></script>
      <script src="https://d3js.org/d3.v4.min.js"></script>

      <style>

        body {
          font: 12px sans-serif;
          margin: 0;
          padding: 0;
        }

        html, body{
          height: 98%;
        }

        #map, #content{
          height: 50%;
          margin: 10px;
        }



        #chart{
          /*margin: 0 auto;*/
          height: 100%;
          /*background-color: red;*/
        }

        #chart > svg{
          display: block;
          margin: 0 auto;
        }

        .bar{
          /*fill: blue;*/
          stroke: none;
          /*opacity: 0.3;*/
        }

      </style>

    </head>
    <body>

      <div id="map"></div>
      <div id="content">
        <div id="chart"></div>
      </div>
      
      <script type="text/javascript">

        // marker styles
        var circleWaiting = {
            color: "red",
            fillColor: "red",
            fillOpacity: 0.5,
            opacity: 0.5,
            radius: 7
        };

        var circleNormal = {
          color: "green",
          fillColor: "green",
          fillOpacity: 0.5,
          opacity: 0.5,
          radius: 5
        }

        // set up map
        var sthlm = [59.311162, 18.074806];
        var circle;
        var map = L.map('map');
        L.tileLayer.provider('OpenStreetMap.BlackAndWhite').addTo(map);
        map.setView(sthlm, 13);

        map.on('click', onMapClick);

        // get date ranges
        var months = 1; // lets start with one to keep the requests down for a while
        var thisYear = { "start": new Date(), "end": new Date(), "key": "present" };
        thisYear.end.setHours(0, 0, 0, 0);
        thisYear.start = new Date(thisYear.end);
        thisYear.start.setMonth(thisYear.start.getMonth() - months); // today - 3 monhts
        var lastYear = { "start": new Date(thisYear.end), "end": new Date(), "key": "past" };
        lastYear.start.setYear(lastYear.start.getFullYear() - 1); // today - 1 year
        lastYear.end = new Date(lastYear.start);
        lastYear.end.setMonth(lastYear.end.getMonth() + months); // (today - 1 yeary) + 3 months
        var dateRanges = [thisYear, lastYear];

        var parseDate = d3.isoParse;

        getNewData(sthlm[0], sthlm[1], dateRanges);

        function onMapClick(e){
          if(circle == null){
            circle = L.circleMarker(e.latlng, circleWaiting).addTo(map);
          }else{
            circle.setLatLng(e.latlng);
            circle.setStyle(circleWaiting);
          }
          getNewData(e.latlng.lat, e.latlng.lng, dateRanges);
        }

        function getNewData(lat, lng, dates){

          // bygg nåt sätt att begära två perioder på en gång
          var callsRemaining = dates.length;
          var data = [];

          dates.forEach(function(range){
            var url = buildUrl(lat, lng, range);
            console.log(window.location.href + url);
            d3.json(url, handleResponse);
          })

          function buildUrl(lat, lng, range){
            return "/darkskySeason?lat=" + lat
              + "&lng=" + lng
              + "&startDate=" + range.start
              + "&endDate=" + range.end;
          }

          function handleResponse(err, json){
            json.data.forEach(function(d){
              d.time = parseDate(d.time * 1000);
                dates.forEach(function(e){
                  if((d.time >= e.start) && (d.time <= e.end)){
                    d.key = e.key;
                  }
                });
              });
            data = data.concat(json.data);
            callsRemaining--;
            if(callsRemaining <= 0){
              done(data);
            }
          }

          function done(data){
            console.log("changing state");
            dispatch.call("statechange", this, data);
          }

        }

        var dispatch = d3.dispatch("init", "load", "statechange", "resize");

        dispatch.on("init.bar", function(){
          var margin = {
            top: 20,
            bottom: 20,
            left: 20,
            right: 20
          };


          var height = parseInt(d3.select("#chart").style("height")) - (margin.top + margin.bottom),
              width = height * 1.77777;

          var svg = d3.select("#chart").append("svg")
            .attr("width", width + (margin.left + margin.right))
            .attr("height", height + (margin.top + margin.bottom))
            .append("g")
              .attr("transform", "translate(" + margin.left + ", " + margin.right + ")");

          // var xScale = d3.scaleTime().rangeRound([0, width]);
          // var xScale = d3.scaleBand().rangeRound([0, width], .05).padding(0.1);
          var xScale = d3.scaleTime()
            .rangeRound([0, width]);
          var yScale = d3.scaleLinear().rangeRound([height, 0]);

          var xAxis = d3.axisBottom(xScale);
          var yAxis = d3.axisLeft(yScale);

          svg.append("g")
            .attr("class", "x axis");
          svg.append("g")
            .attr("class", "y axis");

          dispatch.on("statechange.bar", function(data){
            console.log(data);
            data.forEach(function(d){
              d.temperatureMean = parseFloat(d.temperatureMean);
            });

            // xScale.domain(data.map(function(d){return d.time;}));
            xScale.domain(d3.extent(data, function(d){return d.time;}));
            // console.log(d3.extent(data, function(d){return d.time}));
            var yExtent = d3.extent(data, function(d){return d.temperatureMean;});
            yScale.domain([yExtent[0] - 5, yExtent[1] + 5]);


            var bars = svg.selectAll(".bar")
              .data(data, function(d){
                return d.time;
              });

            bars.exit()
              .transition()
              .attr("y", yScale(0))
              .attr("height", height - yScale(0))
              .remove();

            bars.enter()
              .append("rect")
                .attr("class", "bar")
                .attr("x", function(d) {return xScale(d.time); })
                .attr("width", 1)
                .attr("opacity", function(d){
                  if(d.key == "present"){
                    return 1;
                  }else{
                    return 0.3;
                  }
                })
                .attr("fill", "OliveDrab")
                .attr("y", yScale(0))
                .attr("height", height - yScale(0))
                .transition()
                .delay(250)
                .attr("y", function(d) {return yScale(d.temperatureMean); })
                .attr("height", function(d){ return height - yScale(d.temperatureMean); });
            
            bars.transition()
              .attr("x", function(d){
                return xScale(d.time);
              })
              .attr("y", function(d) {return yScale(d.temperatureMean); })
              .attr("height", function(d){
                return height - yScale(d.temperatureMean);
              });

            xAxis.scale(xScale);
            yAxis.scale(yScale);

            d3.select(".x.axis")
              .attr("transform", "translate(0, " + height + ")")
              .transition()
              .call(xAxis.ticks(10));

            d3.select(".y.axis")
              .transition()
              .call(yAxis);

          });
            
        });

        dispatch.call("init", this);

	    </script>
    
    </body>
</html>





